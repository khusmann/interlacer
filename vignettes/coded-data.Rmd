---
title: "Coded Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Coded Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In addition to interlacing values and missing reasons, many statistical software
packages will store categorical values and missing reasons as alphanumeric
codes. Working with these files can be a pain because the codes are often
arbitrary
[magic numbers](https://en.wikipedia.org/wiki/Magic_number_(programming)#Unnamed_numerical_constants)
that obfuscate the meaning of your syntax and results.

To facilitate working
with such data, interlacer provides a new `cfactor()` type. The `cfactor()`
type allows you to attached labels to coded data and work with it as a regular
R factor. Unlike regular R `factor()` types, however, `cfactors()` can be
converted back into their coded representation at any time (whereas R `factor()`
types lose their original codes).

### ⚠️ ⚠️ ⚠️ WARNING ⚠️ ⚠️ ⚠️

`cfactors()` are an extremely experimental feature and have not been thoroughly
tested yet! I'm sharing them in a super pre-alpha, untested state to get
feedback on them before I invest more time polishing their implementation.

## SPSS-style codes

As a motivating example, consider this coded version of the `colors.csv` example:

```{r}
library(readr)
library(dplyr, warn.conflicts = FALSE)
library(interlacer, warn.conflicts = FALSE)

read_file(
  interlacer_example("colors_coded.csv")
) |>
  cat()
```

Where missing reasons are:

> `-99`: N/A
>
> `-98`: REFUSED
>
> `-97`: OMITTED

And colors are coded:

> `1`: BLUE
>
> `2`: RED
>
> `3`: YELLOW

This style of coding, with positive values representing categorical levels and
negative values representing missing values, is a common format used by SPSS.

These data can be loaded as interlaced numeric values as follows:

```{r}
(df_coded <- read_interlaced_csv(
  interlacer_example("colors_coded.csv"),
  na = c(-99, -98, -97),
  show_col_types = FALSE
))
```

This representation is awkward to work with because the codes are meaningless
and obfuscate the significance of any code you write or any results you output.
If you wanted select everyone with a `BLUE` favorite color, for example, you
would write:

```{r}
df_coded |>
  filter(favorite_color == 1)
```

Similarly, if you wanted to filter for `OMITTED` favorite colors, you would
write:

```{r}
df_coded |>
  filter(favorite_color == na(-97))
```

To make these data more ergnomic to work with, you can use interlacer's
`v_col_cfactor()` and `na_col_cfactor()` collector types to load these values
as a `cfactor()` type instead, which allows you to associate codes with
human-readable labels:

```{r}
(df_decoded <- read_interlaced_csv(
  interlacer_example("colors_coded.csv"),
  col_types = x_cols(
    favorite_color = v_col_cfactor(codes = c(BLUE = 1, RED = 2, YELLOW = 3)),
  ),
  na = na_col_cfactor(REFUSED = -99, OMITTED = -98, `N/A` = -97)
))
```

Now human-readable labels, instead of the magic codes, can be used when working
with the data:

```{r}
df_decoded |>
  filter(favorite_color == "BLUE")

df_decoded |>
  filter(favorite_color == na("OMITTED"))
```

But you can still convert the labels of values or missing reasons back to codes
if you wish, using `as.codes()`:

```{r}
# Selectively re-code value or missing reason channels
df_decoded |>
  mutate(
    age = map_na_channel(age, as.codes),
    favorite_color = map_value_channel(favorite_color, as.codes)
  )

# Or, re-code the entire data frame:
df_decoded |>
  mutate(
    across_value_channels(where_value_channel(is.cfactor), as.codes),
    across_na_channels(where_na_channel(is.cfactor), as.codes),
  )
```

## SAS- and Stata-style codes

Like SPSS, SAS and Stata will encode factor levels as numeric values, but instead of representing missing reasons as negative codes, they are given character codes:

```{r}
read_file(
  interlacer_example("colors_coded_char.csv")
) |>
  cat()
```

In this example, the same value coding scheme is used for `favorite_color`
as the previous example, except the missing reason channels are coded as
follows:

> ".": N/A
>
> ".a": REFUSED
>
> ".b": OMITTED

These data can be easily loaded by interlacer into `cfactor()` types as
follows:

```{r}
read_interlaced_csv(
  interlacer_example("colors_coded_char.csv"),
  col_types = x_cols(
    favorite_color = v_col_cfactor(codes = c(BLUE = 1, RED = 2, YELLOW = 3)),
  ),   
  na = c(`N/A` = ".", REFUSED = ".a", OMITTED = ".b"),
)
```

## The `cfactor()` type

interlacer's `cfactor()` type is an extension of base R's `factor()` type. 
They are created from `numeric` or `character` codes using the `cfactor()`
function:

```{r}
(example_cfactor <- cfactor(
  c(10, 20, 30, 10, 20, 30),
  codes = c(LEVEL_A = 10, LEVEL_B = 20, LEVEL_C = 30)
))

(example_cfactor2 <- cfactor(
  c("a", "b", "c", "a", "b", "c"),
  codes = c(LEVEL_A = "a", LEVEL_B = "b", LEVEL_C = "c")
))
```

`cfactor()` types can be used interchangably with regular `factor()` types: 

```{r}
is.factor(example_cfactor)
levels(example_cfactor)

is.factor(example_cfactor2)
levels(example_cfactor2)
```

But unlike a regular `factor()`, a `cfactor()` additionally stores the codes
for the factor levels. This means you can convert it back into its coded
representation at any time, if desired:

```{r}
codes(example_cfactor)
as.codes(example_cfactor)

codes(example_cfactor2)
as.codes(example_cfactor2)
```

IMPORTANT: The `as.numeric()` and `as.integer()` functions do not convert a
`cfactor()` with numeric codes into its coded representation. Instead, in order
to retain full compatibility with the base R `factor()` type, it always returns
a result coded by the *index* of each level in the factor:

```{r}
as.numeric(example_cfactor)
as.numeric(example_cfactor2)
```

When the levels are changed, the `cfactor()` will drop its codes and degrade
into a regular R factor:

```{r}
library(forcats)

(example_collapsed <- fct_collapse(
  example_cfactor,
  SOMETHING = "LEVEL_A",
  OTHER = c("LEVEL_B", "LEVEL_C")
))

levels(example_collapsed)
codes(example_collapsed)
```

Finally, if you have a base R `factor()` or character vector of labels, you
can add codes to them via `as.cfactor()`:

```{r}
as.cfactor(
  example_collapsed, codes = c(SOMETHING = -999, OTHER = -998)
)
```

## Re-coding and writing a decoded & deinterlaced data frame.

Re-coding and writing an interlaced data frame is as simple as calling
`as.codes()` on all `cfactor()` type value and missing reason channels, and then
calling one of the `write_interlaced_*()` family of functions:

```{r, eval = FALSE}
df_decoded |>
  mutate(
    across_value_channels(where_value_channel(is.cfactor), as.codes),
    across_na_channels(where_na_channel(is.cfactor), as.codes),
  ) |>
  write_interlaced_csv("output.csv")
```

## haven

The [haven](https://haven.tidyverse.org/) package has functions for loading
native SPSS, SAS, and Stata native file formats into
special data frames that use column attributes and special values to keep track
of value labels and missing reasons. For a complete discussion of how this
compares to interlacer's approach, see `vignette("other-approaches")`.
