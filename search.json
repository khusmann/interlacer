[{"path":"http://kylehusmann.com/interlacer/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"Apache License","title":"Apache License","text":"Version 2.0, January 2004 <http://www.apache.org/licenses/>","code":""},{"path":[]},{"path":"http://kylehusmann.com/interlacer/LICENSE.html","id":"id_1-definitions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"1. Definitions","title":"Apache License","text":"“License” shall mean terms conditions use, reproduction, distribution defined Sections 1 9 document. “Licensor” shall mean copyright owner entity authorized copyright owner granting License. “Legal Entity” shall mean union acting entity entities control, controlled , common control entity. purposes definition, “control” means () power, direct indirect, cause direction management entity, whether contract otherwise, (ii) ownership fifty percent (50%) outstanding shares, (iii) beneficial ownership entity. “” (“”) shall mean individual Legal Entity exercising permissions granted License. “Source” form shall mean preferred form making modifications, including limited software source code, documentation source, configuration files. “Object” form shall mean form resulting mechanical transformation translation Source form, including limited compiled object code, generated documentation, conversions media types. “Work” shall mean work authorship, whether Source Object form, made available License, indicated copyright notice included attached work (example provided Appendix ). “Derivative Works” shall mean work, whether Source Object form, based (derived ) Work editorial revisions, annotations, elaborations, modifications represent, whole, original work authorship. purposes License, Derivative Works shall include works remain separable , merely link (bind name) interfaces , Work Derivative Works thereof. “Contribution” shall mean work authorship, including original version Work modifications additions Work Derivative Works thereof, intentionally submitted Licensor inclusion Work copyright owner individual Legal Entity authorized submit behalf copyright owner. purposes definition, “submitted” means form electronic, verbal, written communication sent Licensor representatives, including limited communication electronic mailing lists, source code control systems, issue tracking systems managed , behalf , Licensor purpose discussing improving Work, excluding communication conspicuously marked otherwise designated writing copyright owner “Contribution.” “Contributor” shall mean Licensor individual Legal Entity behalf Contribution received Licensor subsequently incorporated within Work.","code":""},{"path":"http://kylehusmann.com/interlacer/LICENSE.html","id":"id_2-grant-of-copyright-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"2. Grant of Copyright License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable copyright license reproduce, prepare Derivative Works , publicly display, publicly perform, sublicense, distribute Work Derivative Works Source Object form.","code":""},{"path":"http://kylehusmann.com/interlacer/LICENSE.html","id":"id_3-grant-of-patent-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"3. Grant of Patent License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable (except stated section) patent license make, made, use, offer sell, sell, import, otherwise transfer Work, license applies patent claims licensable Contributor necessarily infringed Contribution(s) alone combination Contribution(s) Work Contribution(s) submitted. institute patent litigation entity (including cross-claim counterclaim lawsuit) alleging Work Contribution incorporated within Work constitutes direct contributory patent infringement, patent licenses granted License Work shall terminate date litigation filed.","code":""},{"path":"http://kylehusmann.com/interlacer/LICENSE.html","id":"id_4-redistribution","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"4. Redistribution","title":"Apache License","text":"may reproduce distribute copies Work Derivative Works thereof medium, without modifications, Source Object form, provided meet following conditions: () must give recipients Work Derivative Works copy License; (b) must cause modified files carry prominent notices stating changed files; (c) must retain, Source form Derivative Works distribute, copyright, patent, trademark, attribution notices Source form Work, excluding notices pertain part Derivative Works; (d) Work includes “NOTICE” text file part distribution, Derivative Works distribute must include readable copy attribution notices contained within NOTICE file, excluding notices pertain part Derivative Works, least one following places: within NOTICE text file distributed part Derivative Works; within Source form documentation, provided along Derivative Works; , within display generated Derivative Works, wherever third-party notices normally appear. contents NOTICE file informational purposes modify License. may add attribution notices within Derivative Works distribute, alongside addendum NOTICE text Work, provided additional attribution notices construed modifying License. may add copyright statement modifications may provide additional different license terms conditions use, reproduction, distribution modifications, Derivative Works whole, provided use, reproduction, distribution Work otherwise complies conditions stated License.","code":""},{"path":"http://kylehusmann.com/interlacer/LICENSE.html","id":"id_5-submission-of-contributions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"5. Submission of Contributions","title":"Apache License","text":"Unless explicitly state otherwise, Contribution intentionally submitted inclusion Work Licensor shall terms conditions License, without additional terms conditions. Notwithstanding , nothing herein shall supersede modify terms separate license agreement may executed Licensor regarding Contributions.","code":""},{"path":"http://kylehusmann.com/interlacer/LICENSE.html","id":"id_6-trademarks","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"6. Trademarks","title":"Apache License","text":"License grant permission use trade names, trademarks, service marks, product names Licensor, except required reasonable customary use describing origin Work reproducing content NOTICE file.","code":""},{"path":"http://kylehusmann.com/interlacer/LICENSE.html","id":"id_7-disclaimer-of-warranty","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"7. Disclaimer of Warranty","title":"Apache License","text":"Unless required applicable law agreed writing, Licensor provides Work (Contributor provides Contributions) “” BASIS, WITHOUT WARRANTIES CONDITIONS KIND, either express implied, including, without limitation, warranties conditions TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS PARTICULAR PURPOSE. solely responsible determining appropriateness using redistributing Work assume risks associated exercise permissions License.","code":""},{"path":"http://kylehusmann.com/interlacer/LICENSE.html","id":"id_8-limitation-of-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"8. Limitation of Liability","title":"Apache License","text":"event legal theory, whether tort (including negligence), contract, otherwise, unless required applicable law (deliberate grossly negligent acts) agreed writing, shall Contributor liable damages, including direct, indirect, special, incidental, consequential damages character arising result License use inability use Work (including limited damages loss goodwill, work stoppage, computer failure malfunction, commercial damages losses), even Contributor advised possibility damages.","code":""},{"path":"http://kylehusmann.com/interlacer/LICENSE.html","id":"id_9-accepting-warranty-or-additional-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"9. Accepting Warranty or Additional Liability","title":"Apache License","text":"redistributing Work Derivative Works thereof, may choose offer, charge fee , acceptance support, warranty, indemnity, liability obligations /rights consistent License. However, accepting obligations, may act behalf sole responsibility, behalf Contributor, agree indemnify, defend, hold Contributor harmless liability incurred , claims asserted , Contributor reason accepting warranty additional liability. END TERMS CONDITIONS","code":""},{"path":"http://kylehusmann.com/interlacer/LICENSE.html","id":"appendix-how-to-apply-the-apache-license-to-your-work","dir":"","previous_headings":"","what":"APPENDIX: How to apply the Apache License to your work","title":"Apache License","text":"apply Apache License work, attach following boilerplate notice, fields enclosed brackets [] replaced identifying information. (Don’t include brackets!) text enclosed appropriate comment syntax file format. also recommend file class name description purpose included “printed page” copyright notice easier identification within third-party archives.","code":"Copyright [yyyy] [name of copyright owner]  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."},{"path":"http://kylehusmann.com/interlacer/articles/coded-data.html","id":"numeric-codes-with-negative-missing-reasons-spss","dir":"Articles","previous_headings":"","what":"Numeric codes with negative missing reasons (SPSS)","title":"Coded Data","text":"’s extremely common find data sources encode categorical responses numeric values, negative values representing missing reason codes. SPSS one example. ’s SPSS-formatted version colors.csv example: missing reasons : -99: N/-98: REFUSED -97: OMITTED colors coded: 1: BLUE 2: RED 3: YELLOW format gives ability load everything numeric type: test value missing code, can check ’s less 0: downsides approach twofold: 1) values missing reasons become codes remember 2) ’s really easy make mistakes. sort mistakes? Well, everything numeric, ’s nothing stopping us treating missing reason codes regular values… forget remove missing reason codes, R still happily compute aggregations using negative numbers! fact, math without filtering missing codes potentially ruins integrity data: ever thought significant result, find ’s stray missing reason codes still interlaced values? ’s bad time. ’re much better loading formats interlacer factors, converting codes labels: Now aggregations won’t mix values missing codes, won’t keep cross-referencing codebook know values mean: operations work similar ease:","code":"library(readr) library(interlacer, warn.conflicts = FALSE)  read_file(   interlacer_example(\"colors_coded.csv\") ) |>   cat() #> person_id,age,favorite_color #> 1,20,1 #> 2,-98,1 #> 3,21,-98 #> 4,30,-97 #> 5,1,-99 #> 6,41,2 #> 7,50,-97 #> 8,30,3 #> 9,-98,-98 #> 10,-97,2 #> 11,10,-98 (df_coded <- read_csv(   interlacer_example(\"colors_coded.csv\"),   col_types = \"n\" )) #> # A tibble: 11 × 3 #>    person_id   age favorite_color #>        <dbl> <dbl>          <dbl> #>  1         1    20              1 #>  2         2   -98              1 #>  3         3    21            -98 #>  4         4    30            -97 #>  5         5     1            -99 #>  6         6    41              2 #>  7         7    50            -97 #>  8         8    30              3 #>  9         9   -98            -98 #> 10        10   -97              2 #> 11        11    10            -98 library(dplyr, warn.conflicts = FALSE)  df_coded |>   mutate(     age = if_else(age > 0, age, NA)   ) |>   summarize(     mean_age = mean(age, na.rm = TRUE),     n = n(),     .by = favorite_color   ) |>   arrange(favorite_color) #> # A tibble: 6 × 3 #>   favorite_color mean_age     n #>            <dbl>    <dbl> <int> #> 1            -99      1       1 #> 2            -98     15.5     3 #> 3            -97     40       2 #> 4              1     20       2 #> 5              2     41       2 #> 6              3     30       1 df_coded |>   mutate( #    age = if_else(age > 0, age, NA)   ) |>   summarize(     mean_age = mean(age, na.rm = TRUE),     n = n(),     .by = favorite_color   ) |>   arrange(favorite_color) #> # A tibble: 6 × 3 #>   favorite_color mean_age     n #>            <dbl>    <dbl> <int> #> 1            -99      1       1 #> 2            -98    -22.3     3 #> 3            -97     40       2 #> 4              1    -39       2 #> 5              2    -28       2 #> 6              3     30       1 # This will add 1 to the age values, but ALSO add one to all of the missing # reason codes, resulting in corrupted data! df_coded |>   mutate(     age_next_year = age + 1,   ) #> # A tibble: 11 × 4 #>    person_id   age favorite_color age_next_year #>        <dbl> <dbl>          <dbl>         <dbl> #>  1         1    20              1            21 #>  2         2   -98              1           -97 #>  3         3    21            -98            22 #>  4         4    30            -97            31 #>  5         5     1            -99             2 #>  6         6    41              2            42 #>  7         7    50            -97            51 #>  8         8    30              3            31 #>  9         9   -98            -98           -97 #> 10        10   -97              2           -96 #> 11        11    10            -98            11 # This will give you your intended result, but it's easy to forget df_coded |>   mutate(     age_next_year = if_else(age < 0, age, age + 1),   ) #> # A tibble: 11 × 4 #>    person_id   age favorite_color age_next_year #>        <dbl> <dbl>          <dbl>         <dbl> #>  1         1    20              1            21 #>  2         2   -98              1           -98 #>  3         3    21            -98            22 #>  4         4    30            -97            31 #>  5         5     1            -99             2 #>  6         6    41              2            42 #>  7         7    50            -97            51 #>  8         8    30              3            31 #>  9         9   -98            -98           -98 #> 10        10   -97              2           -97 #> 11        11    10            -98            11 (df_decoded <- read_interlaced_csv(   interlacer_example(\"colors_coded.csv\"),   na = c(-99, -98, -97),   show_col_types = FALSE, ) |>   mutate(     across(       everything(),       \\(x) map_na_channel(         x,         \\(v) factor(           v,           levels = c(-99, -98, -97),           labels = c(\"N/A\", \"REFUSED\", \"OMITTED\"),         )       )     ),     favorite_color = map_value_channel(       favorite_color,       \\(v) factor(         v,         levels = c(1, 2, 3),         labels = c(\"BLUE\", \"RED\", \"YELLOW\")       )     ),   )) #> # A tibble: 11 × 3 #>    person_id       age favorite_color #>    <dbl,fct> <dbl,fct> <fct,fct>      #>  1         1        20 BLUE           #>  2         2 <REFUSED> BLUE           #>  3         3        21 <REFUSED>      #>  4         4        30 <OMITTED>      #>  5         5         1 <N/A>          #>  6         6        41 RED            #>  7         7        50 <OMITTED>      #>  8         8        30 YELLOW         #>  9         9 <REFUSED> <REFUSED>      #> 10        10 <OMITTED> RED            #> 11        11        10 <REFUSED> df_decoded |>   summarize(     mean_age = mean(age, na.rm = TRUE),     n = n(),     .by = favorite_color   ) |>   arrange(favorite_color) #> # A tibble: 6 × 3 #>   favorite_color mean_age     n #>   <fct,fct>         <dbl> <int> #> 1 BLUE               20       2 #> 2 RED                41       2 #> 3 YELLOW             30       1 #> 4 <N/A>               1       1 #> 5 <REFUSED>          15.5     3 #> 6 <OMITTED>          40       2 df_decoded |>   mutate(     age_next_year = age + 1,   ) #> # A tibble: 11 × 4 #>    person_id       age favorite_color age_next_year #>    <dbl,fct> <dbl,fct> <fct,fct>              <dbl> #>  1         1        20 BLUE                      21 #>  2         2 <REFUSED> BLUE                      NA #>  3         3        21 <REFUSED>                 22 #>  4         4        30 <OMITTED>                 31 #>  5         5         1 <N/A>                      2 #>  6         6        41 RED                       42 #>  7         7        50 <OMITTED>                 51 #>  8         8        30 YELLOW                    31 #>  9         9 <REFUSED> <REFUSED>                 NA #> 10        10 <OMITTED> RED                       NA #> 11        11        10 <REFUSED>                 11"},{"path":"http://kylehusmann.com/interlacer/articles/coded-data.html","id":"numeric-codes-with-character-missing-reasons-sas-stata","dir":"Articles","previous_headings":"","what":"Numeric codes with character missing reasons (SAS, Stata)","title":"Coded Data","text":"Like SPSS, SAS Stata encode factor levels numeric values, instead representing missing reasons negative codes, given character codes: , value codes used previous example, except missing reasons coded follows: \".\": N/\".\": REFUSED \".b\": OMITTED handle missing reasons without interlacer, columns must loaded character vectors: test value missing, can cast numeric types. cast fails, know ’s missing code. successful, know ’s coded value. Although character missing codes help prevent us mistakenly including missing codes value aggregations, cast columns numeric time check missingness hardly ergonomic, generates annoying warnings. Like , ’s easier import interlacer decode values missing reasons:","code":"read_file(   interlacer_example(\"colors_coded_char.csv\") ) |>   cat() #> person_id,age,favorite_color #> 1,20,1 #> 2,.a,1 #> 3,21,.a #> 4,30,.b #> 5,1,. #> 6,41,2 #> 7,50,.b #> 8,30,3 #> 9,.a,.a #> 10,.b,2 #> 11,10,.a (df_coded_char <- read_csv(   interlacer_example(\"colors_coded_char.csv\"),   col_types = \"c\" )) #> # A tibble: 11 × 3 #>    person_id age   favorite_color #>    <chr>     <chr> <chr>          #>  1 1         20    1              #>  2 2         .a    1              #>  3 3         21    .a             #>  4 4         30    .b             #>  5 5         1     .              #>  6 6         41    2              #>  7 7         50    .b             #>  8 8         30    3              #>  9 9         .a    .a             #> 10 10        .b    2              #> 11 11        10    .a df_coded_char |>   mutate(     age = if_else(!is.na(as.numeric(age)), as.numeric(age), NA)   ) |>   summarize(     mean_age = mean(age, na.rm = TRUE),     n = n(),     .by = favorite_color   ) |>   arrange(favorite_color) #> Warning: There were 2 warnings in `mutate()`. #> The first warning was: #> ℹ In argument: `age = if_else(!is.na(as.numeric(age)), as.numeric(age), NA)`. #> Caused by warning in `is_logical()`: #> ! NAs introduced by coercion #> ℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning. #> # A tibble: 6 × 3 #>   favorite_color mean_age     n #>   <chr>             <dbl> <int> #> 1 .                   1       1 #> 2 .a                 15.5     3 #> 3 .b                 40       2 #> 4 1                  20       2 #> 5 2                  41       2 #> 6 3                  30       1 read_interlaced_csv(   interlacer_example(\"colors_coded_char.csv\"),   na = c(\".\", \".a\", \".b\"),   show_col_types = FALSE, ) |>   mutate(     across(       everything(),       \\(x) map_na_channel(         x,         \\(v) factor(           v,           levels = c(\".\", \".a\", \".b\"),           labels = c(\"N/A\", \"REFUSED\", \"OMITTED\")         )       )     ),     favorite_color = map_value_channel(       favorite_color,       \\(v) factor(         v,         levels = c(1, 2, 3),         labels = c(\"BLUE\", \"RED\", \"YELLOW\")       )     )   ) #> # A tibble: 11 × 3 #>    person_id       age favorite_color #>    <dbl,fct> <dbl,fct> <fct,fct>      #>  1         1        20 BLUE           #>  2         2 <REFUSED> BLUE           #>  3         3        21 <REFUSED>      #>  4         4        30 <OMITTED>      #>  5         5         1 <N/A>          #>  6         6        41 RED            #>  7         7        50 <OMITTED>      #>  8         8        30 YELLOW         #>  9         9 <REFUSED> <REFUSED>      #> 10        10 <OMITTED> RED            #> 11        11        10 <REFUSED>"},{"path":"http://kylehusmann.com/interlacer/articles/coded-data.html","id":"encoding-a-decoded-deinterlaced-data-frame-","dir":"Articles","previous_headings":"","what":"Encoding a decoded & deinterlaced data frame.","title":"Coded Data","text":"Re-coding re-interlacing data frame can done follows:","code":"library(forcats)  df_decoded |>   mutate(     across(       everything(),       \\(x) map_na_channel(         x,         \\(v) fct_recode(v,           `-99` = \"N/A\",           `-98` = \"REFUSED\",           `-97` = \"OMITTED\"         )       )     ),     favorite_color = map_value_channel(       favorite_color,       \\(v) fct_recode(         v,         `1` = \"BLUE\",         `2` = \"RED\",         `3` = \"YELLOW\"       )     )   ) |>   write_interlaced_csv(\"output.csv\")"},{"path":"http://kylehusmann.com/interlacer/articles/coded-data.html","id":"haven","dir":"Articles","previous_headings":"","what":"haven","title":"Coded Data","text":"haven package functions loading native SPSS, SAS, Stata native file formats special data frames use column attributes special values keep track interlaced values missing reasons. complete discussion compares interlacer’s approach, see vignette(\"-approaches\").","code":""},{"path":"http://kylehusmann.com/interlacer/articles/interlacer.html","id":"aggregations-with-missing-reasons","dir":"Articles","previous_headings":"","what":"Aggregations with missing reasons","title":"Introduction to interlacer","text":"Now, interested values source data, functionality need. wanted know values NA? Although information encoded source data, lost missing reasons converted NA values. example, consider favorite_color column. many respondents REFUSED give favorite color? many people just OMITTED answer? question N/respondents (e.g. wasn’t survey form)? mean respondent age groups? current dataframe gets us part way: can see, converted missing reasons single NA, can answer questions missingness general, rather work specific reasons stored source data. Unfortunately, try load data missing reasons intact, lose something else: type information values. Now access missing reasons, columns character vectors. means order anything values, always filter missing reasons, cast remaining values desired type: gives us information want, cumbersome. Notice ’s distinction favorite color values missing reasons! Things start get really complex different columns different sets possible missing reasons. means lot type conversion gymnastics switch value types missing types.","code":"library(dplyr, warn.conflicts = FALSE)  df_simple |>   summarize(     mean_age = mean(age, na.rm = TRUE),     n = n(),     .by = favorite_color   ) |>   arrange(favorite_color) #> # A tibble: 4 × 3 #>   favorite_color mean_age     n #>   <chr>             <dbl> <int> #> 1 BLUE               20       2 #> 2 RED                41       2 #> 3 YELLOW             30       1 #> 4 NA                 22.4     6 (df_with_missing <- read_csv(   interlacer_example(\"colors.csv\"),   col_types = cols(.default = \"c\"),   show_col_types = FALSE )) #> # A tibble: 11 × 3 #>    person_id age     favorite_color #>    <chr>     <chr>   <chr>          #>  1 1         20      BLUE           #>  2 2         REFUSED BLUE           #>  3 3         21      REFUSED        #>  4 4         30      OMITTED        #>  5 5         1       N/A            #>  6 6         41      RED            #>  7 7         50      OMITTED        #>  8 8         30      YELLOW         #>  9 9         REFUSED REFUSED        #> 10 10        OMITTED RED            #> 11 11        10      REFUSED reasons <- c(\"REFUSED\", \"OMITTED\", \"N/A\")  df_with_missing |>   mutate(     age_values = as.numeric(if_else(age %in% reasons, NA, age)),   ) |>   summarize(     mean_age = mean(age_values, na.rm = TRUE),     n = n(),     .by = favorite_color   ) |>   arrange(favorite_color) #> # A tibble: 6 × 3 #>   favorite_color mean_age     n #>   <chr>             <dbl> <int> #> 1 BLUE               20       2 #> 2 N/A                 1       1 #> 3 OMITTED            40       2 #> 4 RED                41       2 #> 5 REFUSED            15.5     3 #> 6 YELLOW             30       1"},{"path":"http://kylehusmann.com/interlacer/articles/interlacer.html","id":"the-interlacer-approach","dir":"Articles","previous_headings":"Aggregations with missing reasons","what":"The interlacer approach","title":"Introduction to interlacer","text":"interlacer built based insight everything becomes much tidy, simple, expressive explicitly work values missing reasons separate channels variable. interlacer introduces new interlaced column type facilitates . read_interlaced_* functions interlacer import data new column type. can see column headers, column loaded composed two channels: value channel, missing reason channel. channel can type. age column, example, double values factor missing reasons: channels can explicitly accessed using value_channel() na_channel() helper functions: helpers rarely needed, however, computations automatically operate interlaced column’s value channel, ignore missing reasons channel. following compute mean age, without missing reasons interfering: (equivalently used value_channel() helper achieve result, albeit verbosity): Although missing reasons excluded computations, still treated unique values. means group age get breakdown unique missing reasons, rather lumped single NA: can see, can generate report , without needing type gymnastics! Also, values neatly distinguished missing reasons.","code":"(df <- read_interlaced_csv(   interlacer_example(\"colors.csv\"),   na = c(\"REFUSED\", \"OMITTED\", \"N/A\"),   show_col_types = FALSE )) #> # A tibble: 11 × 3 #>    person_id       age favorite_color #>    <dbl,fct> <dbl,fct> <chr,fct>      #>  1         1        20 BLUE           #>  2         2 <REFUSED> BLUE           #>  3         3        21 <REFUSED>      #>  4         4        30 <OMITTED>      #>  5         5         1 <N/A>          #>  6         6        41 RED            #>  7         7        50 <OMITTED>      #>  8         8        30 YELLOW         #>  9         9 <REFUSED> <REFUSED>      #> 10        10 <OMITTED> RED            #> 11        11        10 <REFUSED> df$age #> <interlaced<dbl, fct>[11]> #>  [1] 20        <REFUSED> 21        30        1         41        50        #>  [8] 30        <REFUSED> <OMITTED> 10        #> NA levels: REFUSED OMITTED N/A value_channel(df$age) #>  [1] 20 NA 21 30  1 41 50 30 NA NA 10 na_channel(df$age) #>  [1] <NA>    REFUSED <NA>    <NA>    <NA>    <NA>    <NA>    <NA>    REFUSED #> [10] OMITTED <NA>    #> Levels: REFUSED OMITTED N/A mean(df$age, na.rm = TRUE) #> [1] 25.375 mean(value_channel(df$age), na.rm = TRUE) #> [1] 25.375 df |>   summarize(     mean_age = mean(age, na.rm = TRUE),     n = n(),     .by = favorite_color   ) |>   arrange(favorite_color) #> # A tibble: 6 × 3 #>   favorite_color mean_age     n #>   <chr,fct>         <dbl> <int> #> 1 BLUE               20       2 #> 2 RED                41       2 #> 3 YELLOW             30       1 #> 4 <REFUSED>          15.5     3 #> 5 <OMITTED>          40       2 #> 6 <N/A>               1       1"},{"path":"http://kylehusmann.com/interlacer/articles/interlacer.html","id":"filtering-based-on-missing-reasons","dir":"Articles","previous_headings":"","what":"Filtering based on missing reasons","title":"Introduction to interlacer","text":"interlaced columns also helpful creating samples inclusion / exclusion criteria based missing reasons. example, using example data, say wanted create sample respondents REFUSED give age. indicate value interpreted missing reason, can use na() function value: people REFUSED report age favorite color? ’s also possible combine value conditions missing reason conditions. example, select everyone REFUSED give favorite color, 20 years old:","code":"df |>   filter(age == na(\"REFUSED\")) #> # A tibble: 2 × 3 #>   person_id       age favorite_color #>   <dbl,fct> <dbl,fct> <chr,fct>      #> 1         2 <REFUSED> BLUE           #> 2         9 <REFUSED> <REFUSED> # na_channel() can also be used to get an equivalent result: df |>   filter(na_channel(age) == \"REFUSED\") #> # A tibble: 2 × 3 #>   person_id       age favorite_color #>   <dbl,fct> <dbl,fct> <chr,fct>      #> 1         2 <REFUSED> BLUE           #> 2         9 <REFUSED> <REFUSED> df |>   filter(age == na(\"REFUSED\") & favorite_color == na(\"REFUSED\")) #> # A tibble: 1 × 3 #>   person_id       age favorite_color #>   <dbl,fct> <dbl,fct> <chr,fct>      #> 1         9 <REFUSED> <REFUSED> df |>   filter(age > 20 & favorite_color == na(\"REFUSED\")) #> # A tibble: 1 × 3 #>   person_id       age favorite_color #>   <dbl,fct> <dbl,fct> <chr,fct>      #> 1         3        21 <REFUSED>"},{"path":"http://kylehusmann.com/interlacer/articles/interlacer.html","id":"mutations","dir":"Articles","previous_headings":"","what":"Mutations","title":"Introduction to interlacer","text":"might expect, na() function can used values mutations. following pipeline replace favorite color respondents missing value \"REDACTED\" Conditionals also work exactly expect mutations. following replace favorite color respondents age < 18 missing reason \"REDACTED_UNDERAGE\". Respondents missing age replaced \"REDACTED_MISSING_AGE\" following mutation create new column called person_type \"CHILD\" age < 18, \"ADULT\" age >= 18, missing reason \"AGE_UNAVAILABLE\" age missing: Important note: must use dplyr::if_else() interlaced vectors instead R’s base::ifelse() function, base function strips missing reason channel due fundamental limitation base R.","code":"df |>   mutate(     favorite_color = na(\"REDACTED\")   ) #> # A tibble: 11 × 3 #>    person_id       age favorite_color #>    <dbl,fct> <dbl,fct>      <???,fct> #>  1         1        20     <REDACTED> #>  2         2 <REFUSED>     <REDACTED> #>  3         3        21     <REDACTED> #>  4         4        30     <REDACTED> #>  5         5         1     <REDACTED> #>  6         6        41     <REDACTED> #>  7         7        50     <REDACTED> #>  8         8        30     <REDACTED> #>  9         9 <REFUSED>     <REDACTED> #> 10        10 <OMITTED>     <REDACTED> #> 11        11        10     <REDACTED> df |>   mutate(     favorite_color = if_else(       age < 18,       na(\"REDACTED_UNDERAGE\"),       favorite_color,       missing = na(\"REDACTED_MISSING_AGE\")     )   ) #> # A tibble: 11 × 3 #>    person_id       age favorite_color         #>    <dbl,fct> <dbl,fct> <chr,fct>              #>  1         1        20 BLUE                   #>  2         2 <REFUSED> <REDACTED_MISSING_AGE> #>  3         3        21 <REFUSED>              #>  4         4        30 <OMITTED>              #>  5         5         1 <REDACTED_UNDERAGE>    #>  6         6        41 RED                    #>  7         7        50 <OMITTED>              #>  8         8        30 YELLOW                 #>  9         9 <REFUSED> <REDACTED_MISSING_AGE> #> 10        10 <OMITTED> <REDACTED_MISSING_AGE> #> 11        11        10 <REDACTED_UNDERAGE> df |>   mutate(     person_type = if_else(       age < 18,       \"CHILD\",       \"ADULT\",       missing = na(\"AGE_UNAVAILABLE\")     ),   ) #> # A tibble: 11 × 4 #>    person_id       age favorite_color person_type       #>    <dbl,fct> <dbl,fct> <chr,fct>      <chr,fct>         #>  1         1        20 BLUE           ADULT             #>  2         2 <REFUSED> BLUE           <AGE_UNAVAILABLE> #>  3         3        21 <REFUSED>      ADULT             #>  4         4        30 <OMITTED>      ADULT             #>  5         5         1 <N/A>          CHILD             #>  6         6        41 RED            ADULT             #>  7         7        50 <OMITTED>      ADULT             #>  8         8        30 YELLOW         ADULT             #>  9         9 <REFUSED> <REFUSED>      <AGE_UNAVAILABLE> #> 10        10 <OMITTED> RED            <AGE_UNAVAILABLE> #> 11        11        10 <REFUSED>      CHILD"},{"path":"http://kylehusmann.com/interlacer/articles/interlacer.html","id":"empty-cells-na-missing-reasons","dir":"Articles","previous_headings":"","what":"Empty cells (NA missing reasons)","title":"Introduction to interlacer","text":"cell column missing value missing reason, cell considered “empty”. values can occur missing reasons specified. example, include missing = argument second example previous section, get following result: Empty values can detected using .empty() function: Raw NA values also considered “empty”: Empty values often occur result joins, dplyr::*_join() family functions missing = parameter, like dplyr::if_else() . example, say following data frame wanted join sample: ’re missing condition information respondents, show empty values join data frame sample: can remedy replacing empty values join:","code":"df |>   mutate(     favorite_color = if_else(       age < 18,       na(\"REDACTED_UNDERAGE\"),       favorite_color,     )   ) #> # A tibble: 11 × 3 #>    person_id       age favorite_color      #>    <dbl,fct> <dbl,fct> <chr,fct>           #>  1         1        20 BLUE                #>  2         2 <REFUSED> <<NA>>              #>  3         3        21 <REFUSED>           #>  4         4        30 <OMITTED>           #>  5         5         1 <REDACTED_UNDERAGE> #>  6         6        41 RED                 #>  7         7        50 <OMITTED>           #>  8         8        30 YELLOW              #>  9         9 <REFUSED> <<NA>>              #> 10        10 <OMITTED> <<NA>>              #> 11        11        10 <REDACTED_UNDERAGE> df |>   mutate(     favorite_color = if_else(       age < 18,       na(\"REDACTED_UNDERAGE\"),       favorite_color,     )   ) |>   filter(is.empty(favorite_color)) #> # A tibble: 3 × 3 #>   person_id       age favorite_color #>   <dbl,fct> <dbl,fct> <chr,fct>      #> 1         2 <REFUSED> <<NA>>         #> 2         9 <REFUSED> <<NA>>         #> 3        10 <OMITTED> <<NA>> # regular values are neither missing nor empty is.na(42) #> [1] FALSE is.empty(42) #> [1] FALSE # na(\"REASON\") is a missing value, but is not an empty value is.na(na(\"REASON\")) #> [1] TRUE is.empty(na(\"REASON\")) #> [1] FALSE # na(NA) values are considered missing and empty is.na(na(NA)) #> [1] TRUE is.empty(na(NA)) #> [1] TRUE # regular NA values are also missing and empty is.na(NA) #> [1] TRUE is.empty(NA) #> [1] TRUE conditions <- tribble(   ~person_id, ~condition,   1, \"TREATMENT\",   2, \"CONTROL\",   3, na(\"TECHNICAL_ERROR\"),   6, \"CONTROL\",   8, \"TREATMENT\", ) df |>   left_join(conditions, by = join_by(person_id)) #> # A tibble: 11 × 4 #>    person_id       age favorite_color condition         #>    <dbl,fct> <dbl,fct> <chr,fct>      <chr,fct>         #>  1         1        20 BLUE           TREATMENT         #>  2         2 <REFUSED> BLUE           CONTROL           #>  3         3        21 <REFUSED>      <TECHNICAL_ERROR> #>  4         4        30 <OMITTED>      <<NA>>            #>  5         5         1 <N/A>          <<NA>>            #>  6         6        41 RED            CONTROL           #>  7         7        50 <OMITTED>      <<NA>>            #>  8         8        30 YELLOW         TREATMENT         #>  9         9 <REFUSED> <REFUSED>      <<NA>>            #> 10        10 <OMITTED> RED            <<NA>>            #> 11        11        10 <REFUSED>      <<NA>> df |>   left_join(conditions, by = join_by(person_id)) |>   mutate(     condition = if_else(is.empty(condition), na(\"LEFT_STUDY\"), condition),   ) #> # A tibble: 11 × 4 #>    person_id       age favorite_color condition         #>    <dbl,fct> <dbl,fct> <chr,fct>      <chr,fct>         #>  1         1        20 BLUE           TREATMENT         #>  2         2 <REFUSED> BLUE           CONTROL           #>  3         3        21 <REFUSED>      <TECHNICAL_ERROR> #>  4         4        30 <OMITTED>      <LEFT_STUDY>      #>  5         5         1 <N/A>          <LEFT_STUDY>      #>  6         6        41 RED            CONTROL           #>  7         7        50 <OMITTED>      <LEFT_STUDY>      #>  8         8        30 YELLOW         TREATMENT         #>  9         9 <REFUSED> <REFUSED>      <LEFT_STUDY>      #> 10        10 <OMITTED> RED            <LEFT_STUDY>      #> 11        11        10 <REFUSED>      <LEFT_STUDY>"},{"path":"http://kylehusmann.com/interlacer/articles/interlacer.html","id":"writing-interlaced-files","dir":"Articles","previous_headings":"","what":"Writing interlaced files","title":"Introduction to interlacer","text":"’ve made made changes data, probably want save . interlacer provides write_interlaced_* family functions : combine value missing reasons interlaced character columns, write result csv. Alternatively, want re-interlace columns without writing file control writing process, can use flatten_channels(): value missing reason channels data frames interlaced vectors can similarly accessed using value_channel() na_channel() helper functions:","code":"write_interlaced_csv(df, \"interlaced_output.csv\") flatten_channels(df) #> # A tibble: 11 × 3 #>    person_id age     favorite_color #>        <dbl> <chr>   <chr>          #>  1         1 20      BLUE           #>  2         2 REFUSED BLUE           #>  3         3 21      REFUSED        #>  4         4 30      OMITTED        #>  5         5 1       N/A            #>  6         6 41      RED            #>  7         7 50      OMITTED        #>  8         8 30      YELLOW         #>  9         9 REFUSED REFUSED        #> 10        10 OMITTED RED            #> 11        11 10      REFUSED # (it works on single vectors as well) flatten_channels(df$age) #>  [1] \"20\"      \"REFUSED\" \"21\"      \"30\"      \"1\"       \"41\"      \"50\"      #>  [8] \"30\"      \"REFUSED\" \"OMITTED\" \"10\" value_channel(df) #> # A tibble: 11 × 3 #>    person_id   age favorite_color #>        <dbl> <dbl> <chr>          #>  1         1    20 BLUE           #>  2         2    NA BLUE           #>  3         3    21 NA             #>  4         4    30 NA             #>  5         5     1 NA             #>  6         6    41 RED            #>  7         7    50 NA             #>  8         8    30 YELLOW         #>  9         9    NA NA             #> 10        10    NA RED            #> 11        11    10 NA na_channel(df) #> # A tibble: 11 × 3 #>    person_id age     favorite_color #>    <fct>     <fct>   <fct>          #>  1 NA        NA      NA             #>  2 NA        REFUSED NA             #>  3 NA        NA      REFUSED        #>  4 NA        NA      OMITTED        #>  5 NA        NA      N/A            #>  6 NA        NA      NA             #>  7 NA        NA      OMITTED        #>  8 NA        NA      NA             #>  9 NA        REFUSED REFUSED        #> 10 NA        OMITTED NA             #> 11 NA        NA      REFUSED"},{"path":"http://kylehusmann.com/interlacer/articles/interlacer.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next steps","title":"Introduction to interlacer","text":"far, ’ve covered interlacer’s read_interlaced_* family functions enabled us load interlaced columns contain separate challens value missing reasons. interlaced type enables us create tidy type-aware pipelines can flexibly consider variable’s value missing reasons. examples vignette, column types automatically detected. explicitly specify value missing column types, (specify individual missing reasons specific columns), interlacer extends readr’s collector() system. covered next vignette, vignette(\"na-column-types\").","code":""},{"path":"http://kylehusmann.com/interlacer/articles/na-column-types.html","id":"na-collector-types","dir":"Articles","previous_headings":"","what":"NA collector types","title":"NA Column Types","text":"addition standard readr::col_* column specification types, interlacer provides ability specify missing reasons column level, using na parameter. useful missing reasons apply particular items opposed file whole. example, say measure following two items: current stress level? Low Moderate High don’t know don’t understand question well feel manage time responsibilities today? Poorly Fairly well Well well apply (Today vacation day) apply (reason) can see, items two selection choices mapped missing reasons. can specified na_cols() function, works similarly readr’s cols() function: Setting na type NULL indicates column loaded regular type instead interlaced one. following load person_id regular, non-interlaced type:","code":"(df_stress <- read_interlaced_csv(   interlacer_example(\"stress.csv\"),   col_types = cols(     person_id = col_integer(),     current_stress = col_factor(       levels = c(\"LOW\", \"MODERATE\", \"HIGH\")     ),     time_management = col_factor(       levels = c(\"POORLY\", \"FAIRLY_WELL\", \"WELL\", \"VERY_WELL\")     )   ),   na = na_cols(     .default = c(\"REFUSED\", \"OMITTED\", \"N/A\"),     current_stress = c(.default, \"DONT_KNOW\", \"DONT_UNDERSTAND\"),     time_management = c(.default, \"NA_VACATION\", \"NA_OTHER\")   ) )) #> # A tibble: 8 × 3 #>   person_id current_stress    time_management #>   <int,fct> <fct,fct>         <fct,fct>       #> 1         1 LOW               VERY_WELL       #> 2         2 MODERATE          POORLY          #> 3         3 <DONT_KNOW>       <NA_OTHER>      #> 4         4 HIGH              POORLY          #> 5         5 <DONT_UNDERSTAND> <NA_OTHER>      #> 6         6 LOW               <NA_VACATION>   #> 7         7 MODERATE          WELL            #> 8         8 <OMITTED>         FAIRLY_WELL read_interlaced_csv(   interlacer_example(\"colors_coded.csv\"),   na = na_cols(     .default = c(-99, -98, -97),     person_id = NULL,   ),   show_col_types = FALSE ) #> # A tibble: 11 × 3 #>    person_id       age favorite_color #>        <dbl> <dbl,int>      <dbl,int> #>  1         1        20              1 #>  2         2     <-98>              1 #>  3         3        21          <-98> #>  4         4        30          <-97> #>  5         5         1          <-99> #>  6         6        41              2 #>  7         7        50          <-97> #>  8         8        30              3 #>  9         9     <-98>          <-98> #> 10        10     <-97>              2 #> 11        11        10          <-98>"},{"path":"http://kylehusmann.com/interlacer/articles/na-column-types.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next steps","title":"NA Column Types","text":"vignette covered column types values missing reasons can explicitly specified using collectors. also illustrated column-level missing values can specified creating missing channel specification using na_cols(). final example, used example data set coded values missing reasons. Coded values especially common data sets produced SPSS, SAS, Stata. recipes working coded data like , check next vignette, vignette(\"coded-data\").","code":""},{"path":"http://kylehusmann.com/interlacer/articles/other-approaches.html","id":"haven-and-labelled","dir":"Articles","previous_headings":"","what":"haven and labelled","title":"Other Approaches","text":"haven labelled packages rely two functions creating vectors interlace values missing reasons: haven::labelled_spss() haven::tagged_na(). Although create haven_labelled vectors, use different methods representing missing values.","code":""},{"path":"http://kylehusmann.com/interlacer/articles/other-approaches.html","id":"labelled-missing-values-havenlabelled_spss","dir":"Articles","previous_headings":"haven and labelled","what":"“Labelled” missing values (haven::labelled_spss())","title":"Other Approaches","text":"SPSS files loaded haven via haven::read_spss(), values missing reasons loaded single interlaced numeric vector: just numeric vector though, haven::labelled_spss() numeric vector, attributes describing value missing value codes: attributes adjust behavior functions like .na(): makes easy check value missing reason, still filter missing reasons aggregations: ’s little bit improvement working raw coded values, can use .na(), codes get labels, don’t constantly looking codes codebook. still falls short interlacer’s functionality two key reasons: Reason 1: interlacer, value column can whatever type want: numeric, character, factor, etc. labelled missing reasons, values missing reasons need type, usually numeric codes. creates lot type gymnastics potential errors ’re manipulating . Reason 2: Even missing values labelled labelled_spss type, aggregations math operations protected. forget take missing values, get incorrect results / corrupted data:","code":"library(interlacer, warn.conflicts = FALSE) library(haven) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union (df_spss <- read_spss(   interlacer_example(\"colors.sav\"), user_na = TRUE )) #> # A tibble: 11 × 3 #>    person_id age                favorite_color     #>    <dbl+lbl> <dbl+lbl>          <dbl+lbl>          #>  1  1         20                  1 [BLUE]         #>  2  2        -98 (NA) [REFUSED]   1 [BLUE]         #>  3  3         21                -98 (NA) [REFUSED] #>  4  4         30                -97 (NA) [OMITTED] #>  5  5          1                -99 (NA) [N/A]     #>  6  6         41                  2 [RED]          #>  7  7         50                -97 (NA) [OMITTED] #>  8  8         30                  3 [YELLOW]       #>  9  9        -98 (NA) [REFUSED] -98 (NA) [REFUSED] #> 10 10        -97 (NA) [OMITTED]   2 [RED]          #> 11 11         10                -98 (NA) [REFUSED] attributes(df_spss$favorite_color) #> $label #> [1] \"Favorite color\" #>  #> $na_range #> [1] -Inf    0 #>  #> $class #> [1] \"haven_labelled_spss\" \"haven_labelled\"      \"vctrs_vctr\"          #> [4] \"double\"              #>  #> $format.spss #> [1] \"F8.2\" #>  #> $labels #>    BLUE     RED  YELLOW     N/A REFUSED OMITTED  #>       1       2       3     -99     -98     -97 is.na(df_spss$favorite_color) #>  [1] FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE df_spss |>   mutate(     age_values = if_else(is.na(age), NA, age),     favorite_color_missing_reasons = if_else(       is.na(favorite_color), favorite_color, NA     )   ) |>   summarize(     mean_age = mean(age_values, na.rm = TRUE),     n = n(),     .by = favorite_color_missing_reasons   ) #> # A tibble: 4 × 3 #>   favorite_color_missing_reasons mean_age     n #>   <dbl+lbl>                         <dbl> <int> #> 1  NA                                30.3     5 #> 2 -98 (NA) [REFUSED]                 15.5     3 #> 3 -97 (NA) [OMITTED]                 40       2 #> 4 -99 (NA) [N/A]                      1       1 df_spss |>   mutate(     age_next_year = if_else(is.na(age), NA, age + 1),     .after = person_id   ) #> # A tibble: 11 × 4 #>    person_id age_next_year age                favorite_color     #>    <dbl+lbl>         <dbl> <dbl+lbl>          <dbl+lbl>          #>  1  1                   21  20                  1 [BLUE]         #>  2  2                   NA -98 (NA) [REFUSED]   1 [BLUE]         #>  3  3                   22  21                -98 (NA) [REFUSED] #>  4  4                   31  30                -97 (NA) [OMITTED] #>  5  5                    2   1                -99 (NA) [N/A]     #>  6  6                   42  41                  2 [RED]          #>  7  7                   51  50                -97 (NA) [OMITTED] #>  8  8                   31  30                  3 [YELLOW]       #>  9  9                   NA -98 (NA) [REFUSED] -98 (NA) [REFUSED] #> 10 10                   NA -97 (NA) [OMITTED]   2 [RED]          #> 11 11                   11  10                -98 (NA) [REFUSED] df_spss |>   mutate(     favorite_color_missing_reasons = if_else(       is.na(favorite_color), favorite_color, NA     )   ) |>   summarize(     mean_age = mean(age, na.rm = TRUE),     n = n(),     .by = favorite_color_missing_reasons   ) #> # A tibble: 4 × 3 #>   favorite_color_missing_reasons mean_age     n #>   <dbl+lbl>                         <dbl> <int> #> 1  NA                               -20.8     5 #> 2 -98 (NA) [REFUSED]                -22.3     3 #> 3 -97 (NA) [OMITTED]                 40       2 #> 4 -99 (NA) [N/A]                      1       1 df_spss |>   mutate(     age_next_year = age + 1,     .after = person_id   ) #> # A tibble: 11 × 4 #>    person_id age_next_year age                favorite_color     #>    <dbl+lbl>         <dbl> <dbl+lbl>          <dbl+lbl>          #>  1  1                   21  20                  1 [BLUE]         #>  2  2                  -97 -98 (NA) [REFUSED]   1 [BLUE]         #>  3  3                   22  21                -98 (NA) [REFUSED] #>  4  4                   31  30                -97 (NA) [OMITTED] #>  5  5                    2   1                -99 (NA) [N/A]     #>  6  6                   42  41                  2 [RED]          #>  7  7                   51  50                -97 (NA) [OMITTED] #>  8  8                   31  30                  3 [YELLOW]       #>  9  9                  -97 -98 (NA) [REFUSED] -98 (NA) [REFUSED] #> 10 10                  -96 -97 (NA) [OMITTED]   2 [RED]          #> 11 11                   11  10                -98 (NA) [REFUSED]"},{"path":"http://kylehusmann.com/interlacer/articles/other-approaches.html","id":"tagged-missing-values-haventagged_na","dir":"Articles","previous_headings":"haven and labelled","what":"“Tagged” missing values (haven::tagged_na())","title":"Other Approaches","text":"loading Stata SAS files, haven uses “tagged missingness” approach mirror values handled Stata SAS: approach deviously clever. takes advantage way NaN floating point values stored memory, make possible different “flavors” NA values. (info done, check tagged_na.c source code haven) still act like regular NA values… now can include single character “tag” (usually letter -z). means work .na() include missing reason codes aggregations! Unfortunately, can’t group , dplyr::group_by() tag-aware. :( Another limitation approach requires values types numeric, trick “tagging” NA values depends peculiarities floating point values stored memory.","code":"(df_stata <- read_stata(   interlacer_example(\"colors.dta\") )) #> # A tibble: 11 × 3 #>    person_id age             favorite_color  #>    <dbl+lbl> <dbl+lbl>       <dbl+lbl>       #>  1  1           20               1 [BLUE]    #>  2  2        NA(a) [REFUSED]     1 [BLUE]    #>  3  3           21           NA(a) [REFUSED] #>  4  4           30           NA(b) [OMITTED] #>  5  5            1              NA           #>  6  6           41               2 [RED]     #>  7  7           50           NA(b) [OMITTED] #>  8  8           30               3 [YELLOW]  #>  9  9        NA(a) [REFUSED] NA(a) [REFUSED] #> 10 10        NA(b) [OMITTED]     2 [RED]     #> 11 11           10           NA(a) [REFUSED] is.na(df_stata$age) #>  [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE mean(df_stata$age, na.rm = TRUE) #> [1] 25.375 df_stata |>   mutate(     favorite_color_missing_reasons = if_else(       is.na(favorite_color), favorite_color, NA     )   ) |>   summarize(     mean_age = mean(age, na.rm = TRUE),     n = n(),     .by = favorite_color_missing_reasons   ) #> # A tibble: 1 × 3 #>   favorite_color_missing_reasons mean_age     n #>   <dbl+lbl>                         <dbl> <int> #> 1 NA                                 25.4    11"},{"path":"http://kylehusmann.com/interlacer/articles/other-approaches.html","id":"declared","dir":"Articles","previous_headings":"","what":"declared","title":"Other Approaches","text":"declared package uses functiondeclared::declared() constructing interlaced vectors: declared vectors similar haven_labelled_spss vectors, except critical innovation: store actual NA values missing values, keep track missing reasons entirely attributes object: means aggregations work exactly expect!","code":"library(declared) #>  #> Attaching package: 'declared' #> The following object is masked from 'package:interlacer': #>  #>     is.empty (dcl <- declared(c(1, 2, 3, -99, -98), na_values = c(-99, -98))) #> <declared<numeric>[5]> #> [1]       1       2       3 NA(-99) NA(-98) #> Missing values: -99, -98 # All the missing reason info is tracked in the attributes attributes(dcl) #> $na_index #> -99 -98  #>   4   5  #>  #> $na_values #> [1] -99 -98 #>  #> $date #> [1] FALSE #>  #> $class #> [1] \"declared\" \"numeric\" # The data stored has actual NA values, so it works as you would expect # with summary stats like `mean()`, etc. attributes(dcl) <- NULL dcl #> [1]  1  2  3 NA NA dcl <- declared(c(1, 2, 3, -99, -98), na_values = c(-99, -98))  sum(dcl, na.rm = TRUE) #> [1] 6"},{"path":"http://kylehusmann.com/interlacer/articles/other-approaches.html","id":"interlacer","dir":"Articles","previous_headings":"","what":"interlacer","title":"Other Approaches","text":"interlacer builds ideas haven, labelled, declared following goals:","code":""},{"path":"http://kylehusmann.com/interlacer/articles/other-approaches.html","id":"be-fully-generic-add-a-missing-value-channel-to-any-vector-type","dir":"Articles","previous_headings":"interlacer","what":"1. Be fully generic: Add a missing value channel to any vector type","title":"Other Approaches","text":"mentioned , haven::labelled_spss() works numeric character types, haven::tagged_na() works numeric types. declared::declared() supports numeric, character date types. interlaced types, contrast, can imbue vector type missing value channel: Like declared vectors, missing reasons tracked attributes. unlike declared, missing reasons stored entirely separate channel rather tracking indices: data structure drives functional API, described (3) .","code":"interlaced(list(TRUE, FALSE, \"reason\"), na = \"reason\") #> <interlaced<lgl, fct>[3]> #> [1] TRUE     FALSE    <reason> #> NA levels: reason interlaced(c(\"2020-01-01\", \"2020-01-02\", \"reason\"), na = \"reason\") |>   map_value_channel(as.Date) #> <interlaced<date, fct>[3]> #> [1] 2020-01-01 2020-01-02 <reason>   #> NA levels: reason interlaced(c(\"red\", \"green\", \"reason\"), na = \"reason\") |>   map_value_channel(factor) #> <interlaced<fct, fct>[3]> #> [1] red      green    <reason> #> Levels: green red  #> NA levels: reason (int <- interlaced(c(1,2,3, -99, -98), na = c(-99, -98))) #> <interlaced<dbl, int>[5]> #> [1] 1     2     3     <-99> <-98> attributes(int) #> $na_channel_values #> [1]  NA  NA  NA -99 -98 #>  #> $class #> [1] \"interlacer_interlaced\" \"vctrs_vctr\"            \"numeric\" attributes(int) <- NULL int #> [1]  1  2  3 NA NA"},{"path":"http://kylehusmann.com/interlacer/articles/other-approaches.html","id":"provide-functions-for-reading-writing-interlaced-csv-files-not-just-spss-sas-stata-files","dir":"Articles","previous_headings":"interlacer","what":"2. Provide functions for reading / writing interlaced CSV files (not just SPSS / SAS / Stata files)","title":"Other Approaches","text":"See interlacer::read_interlaced_csv(), etc.","code":""},{"path":"http://kylehusmann.com/interlacer/articles/other-approaches.html","id":"provide-a-functional-api-that-integrates-well-into-tidy-pipelines","dir":"Articles","previous_headings":"interlacer","what":"3. Provide a functional API that integrates well into tidy pipelines","title":"Other Approaches","text":"interlacer provides functions facilitate working interlaced type Result type, well-understood abstraction functional programming. functions na() map_value_channel() map_na_channel() come influence. na() function creates interlaced type “lifting” value missing reason channel. approach helps create safer separation value missing reason channels, ’s always clear channel ’re making comparisons . example: Similarly, map_value_channel() map_na_channel() allow safely mutate particular channel, without touching values channel. interface especially useful tidy pipelines. Finally, interlaced type based vctrs type system, plays nicely packages tidyverse.","code":"# haven labelled_spss(c(-99, 1, 2), na_values = -99) == 1 # value channel comparison #> [1] FALSE  TRUE FALSE labelled_spss(c(-99, 1, 2), na_values = -99) == -99 # na channel comparison #> [1]  TRUE FALSE FALSE # declared declared(c(-99, 1, 2), na_values = -99) == 1 # value channel comparison #> [1] FALSE  TRUE FALSE declared(c(-99, 1, 2), na_values = -99) == -99 # na channel comparison #> [1]  TRUE FALSE FALSE # interlacer  interlaced(c(-99, 1, 2), na = -99) == 1 # value channel comparison #> [1] FALSE  TRUE FALSE interlaced(c(-99, 1, 2), na = -99) == na(-99) # na channel comparison #> [1]  TRUE FALSE FALSE"},{"path":[]},{"path":"http://kylehusmann.com/interlacer/articles/other-approaches.html","id":"more-flexible-missing-reason-channel-types","dir":"Articles","previous_headings":"Questions for the future","what":"1. More flexible missing reason channel types?","title":"Other Approaches","text":"Earlier versions allowed arbitrary types occupy missing reason channel (.e. fully generic Result<Value, Missing> type). ended constricting missing reason channel allow integer factor types help simplify na_cols() specifications. arbitrary types allowed, na_cols() specs become quite long (e.g. column_name = factor(levels=c(\"REASON_1\", \"REASON_2\")))). far can tell, 99.9% time, preferable use integer factor missing reason channels double character ones, now ’ve made executive decision allow integer factor types.","code":""},{"path":"http://kylehusmann.com/interlacer/articles/other-approaches.html","id":"a-better-na_cols-specification","dir":"Articles","previous_headings":"Questions for the future","what":"2. A better na_cols() specification?","title":"Other Approaches","text":"Right now, missing values supplied separate argument col_types. means custom missing values get pretty far separated col_type definitions: earlier version created extension readr collectors, family icol_* types, allowed something like : …can’t decide interface like better. Although latter approach feels cleaner folds custom missing reasons cols definition, one disadvantage overwrite missing values (e.g. set missing reason person_id NULL long ’s default missing reason specified). also feels little “hackish” extend readr’s types way; think making use na parameter na_cols() function provides little bit insulation changes readr. Anyway, thoughts opinions things, ’d really appreciate feedback!","code":"read_interlaced_csv(   interlacer_example(\"stress.csv\"),   col_types = cols(     person_id = col_integer(),     current_stress = col_factor(       levels = c(\"LOW\", \"MODERATE\", \"HIGH\")     ),     time_management = col_factor(       levels = c(\"POORLY\", \"FAIRLY_WELL\", \"WELL\", \"VERY_WELL\")     )   ),   na = na_cols(     .default = c(\"REFUSED\", \"OMITTED\", \"N/A\"),     current_stress = c(.default, \"DONT_KNOW\", \"DONT_UNDERSTAND\"),     time_management = c(.default, \"NA_VACATION\", \"NA_OTHER\")   ) ) #> # A tibble: 8 × 3 #>   person_id current_stress    time_management #>   <int,fct> <fct,fct>         <fct,fct>       #> 1         1 LOW               VERY_WELL       #> 2         2 MODERATE          POORLY          #> 3         3 <DONT_KNOW>       <NA_OTHER>      #> 4         4 HIGH              POORLY          #> 5         5 <DONT_UNDERSTAND> <NA_OTHER>      #> 6         6 LOW               <NA_VACATION>   #> 7         7 MODERATE          WELL            #> 8         8 <OMITTED>         FAIRLY_WELL read_interlaced_csv(   interlacer_example(\"stress.csv\"),   col_types = cols(     person_id = col_integer(),     current_stress = icol_factor(       levels = c(\"LOW\", \"MODERATE\", \"HIGH\"),       na = c(\"DONT_KNOW\", \"DONT_UNDERSTAND\")     ),     time_management = col_factor(       levels = c(\"POORLY\", \"FAIRLY_WELL\", \"WELL\", \"VERY_WELL\"),       na = c(\"NA_VACATION\", \"NA_OTHER\")     )   ),   na = c(\"REFUSED\", \"OMITTED\", \"N/A\") )"},{"path":"http://kylehusmann.com/interlacer/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kyle Husmann. Author, maintainer.","code":""},{"path":"http://kylehusmann.com/interlacer/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Husmann K (2024). interlacer: Read Tabular Data Interlaced Values Missing Reasons. R package version 0.2.2, http://kylehusmann.com/interlacer/.","code":"@Manual{,   title = {interlacer: Read Tabular Data With Interlaced Values And Missing Reasons},   author = {Kyle Husmann},   year = {2024},   note = {R package version 0.2.2},   url = {http://kylehusmann.com/interlacer/}, }"},{"path":"http://kylehusmann.com/interlacer/index.html","id":"interlacer-","dir":"","previous_headings":"","what":"Read Tabular Data With Interlaced Values And Missing Reasons","title":"Read Tabular Data With Interlaced Values And Missing Reasons","text":"value missing data, sometimes want know missing. Many textual tabular data sources encode missing reasons special values interlaced regular values column (e.g. N/, REFUSED, -99, etc.). Unfortunately, missing reasons lost values converted single NA type. Working missing reasons R traditionally requires loading variables character vectors bunch string comparisons type conversions make sense . interlacer provides functions load variables interlaced data sources special interlaced column type holds values NA reasons separate channels variable. contexts, can treat interlaced columns regular values: take mean interlaced column, example, get mean values, without missing reasons interfering computation. Unlike regular column, however, missing reasons still available. means can still filter data frames variables specific missing reasons, generate summary statistics breakdowns missing reason. words, longer constantly manually include / exclude missing reasons computations filtering awkward string comparisons type conversions… everything just works! addition introduction vignette(\"interlacer\") sure also check : vignette(\"na-column-types\") see handle variable-level missing reasons vignette(\"coded-data\") recipies working coded data (e.g. data produced SPSS, SAS Stata) vignette(\"-approaches\") deep dive interlacer’s approach compares approaches representing manipulating missing reasons alongside data values","code":""},{"path":"http://kylehusmann.com/interlacer/index.html","id":"id_️-️-️-warning-️-️-️","dir":"","previous_headings":"","what":"⚠️ ⚠️ ⚠️ WARNING ⚠️ ⚠️ ⚠️","title":"Read Tabular Data With Interlaced Values And Missing Reasons","text":"library currently experimental stages, aware interface quite likely change future. meantime, please try let know think!","code":""},{"path":"http://kylehusmann.com/interlacer/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Read Tabular Data With Interlaced Values And Missing Reasons","text":"easiest way get interlacer install via devtools:","code":"install.packages(\"devtools\") # If devtools is not already installed  devtools::install_github(\"khusmann/interlacer\")"},{"path":"http://kylehusmann.com/interlacer/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Read Tabular Data With Interlaced Values And Missing Reasons","text":"use interlacer, load current R session: interlacer supports following file formats read_interlaced_*() functions, extend readr::read_*() family functions: read_interlaced_csv() read_interlaced_tsv() read_interlaced_csv2() read_interlaced_delim() quick demo, consider following example file bundled interlacer: csv file, values interlaced three possible missing reasons: REFUSED, OMITTED, N/. readr, loading data result data frame missing reasons replaced NA: interlacer, missing reasons preserved: can see, printout column defined two types: type values, type missing reasons. age column, example, type double values, type factor missing reasons: Computations automatically operate values: missing reasons still ! indicate value treated missing reason instead regular value, can use na() function. following, example, filter data set individuals REFUSED give favorite color: ’s pipeline compute breakdown mean age respondents favorite color, separate categories missing reason: just scratches surface can done interlacer… check vignette(\"interlacer\") complete overview!","code":"library(interlacer, warn.conflicts = FALSE) library(dplyr, warn.conflicts = FALSE) library(readr)  read_file(interlacer_example(\"colors.csv\")) |>   cat() #> person_id,age,favorite_color #> 1,20,BLUE #> 2,REFUSED,BLUE #> 3,21,REFUSED #> 4,30,OMITTED #> 5,1,N/A #> 6,41,RED #> 7,50,OMITTED #> 8,30,YELLOW #> 9,REFUSED,REFUSED #> 10,OMITTED,RED #> 11,10,REFUSED read_csv(   interlacer_example(\"colors.csv\"),   na = c(\"REFUSED\", \"OMITTED\", \"N/A\"),   show_col_types = FALSE, ) #> # A tibble: 11 × 3 #>    person_id   age favorite_color #>        <dbl> <dbl> <chr>          #>  1         1    20 BLUE           #>  2         2    NA BLUE           #>  3         3    21 <NA>           #>  4         4    30 <NA>           #>  5         5     1 <NA>           #>  6         6    41 RED            #>  7         7    50 <NA>           #>  8         8    30 YELLOW         #>  9         9    NA <NA>           #> 10        10    NA RED            #> 11        11    10 <NA> (ex <- read_interlaced_csv(   interlacer_example(\"colors.csv\"),   na = c(\"REFUSED\", \"OMITTED\", \"N/A\"),   show_col_types = FALSE, )) #> # A tibble: 11 × 3 #>    person_id       age favorite_color #>    <dbl,fct> <dbl,fct> <chr,fct>      #>  1         1        20 BLUE           #>  2         2 <REFUSED> BLUE           #>  3         3        21 <REFUSED>      #>  4         4        30 <OMITTED>      #>  5         5         1 <N/A>          #>  6         6        41 RED            #>  7         7        50 <OMITTED>      #>  8         8        30 YELLOW         #>  9         9 <REFUSED> <REFUSED>      #> 10        10 <OMITTED> RED            #> 11        11        10 <REFUSED> ex$age #> <interlaced<dbl, fct>[11]> #>  [1] 20        <REFUSED> 21        30        1         41        50        #>  [8] 30        <REFUSED> <OMITTED> 10        #> NA levels: REFUSED OMITTED N/A mean(ex$age, na.rm = TRUE) #> [1] 25.375 ex |>   filter(favorite_color == na(\"REFUSED\")) #> # A tibble: 3 × 3 #>   person_id       age favorite_color #>   <dbl,fct> <dbl,fct> <chr,fct>      #> 1         3        21 <REFUSED>      #> 2         9 <REFUSED> <REFUSED>      #> 3        11        10 <REFUSED> ex |>   summarize(     mean_age = mean(age, na.rm = TRUE),     n = n(),     .by = favorite_color   ) %>%   arrange(favorite_color) #> # A tibble: 6 × 3 #>   favorite_color mean_age     n #>   <chr,fct>         <dbl> <int> #> 1 BLUE               20       2 #> 2 RED                41       2 #> 3 YELLOW             30       1 #> 4 <REFUSED>          15.5     3 #> 5 <OMITTED>          40       2 #> 6 <N/A>               1       1"},{"path":"http://kylehusmann.com/interlacer/index.html","id":"known-issues","dir":"","previous_headings":"","what":"Known Issues","title":"Read Tabular Data With Interlaced Values And Missing Reasons","text":"base functions, like base::ifelse(), drop missing reason channel interlaced types, converting regular vectors example: due limitation R. run , use tidyverse equivalent function. Tidyverse functions designed correctly handle type conversions. example, can use dplyr::if_else(): Performance large data sets may notice large datasets interlacer runs significantly slower readr / vroom. Although interlacer uses vroom hood load delimited data, able take advantage many optimizations vroom currently support column-level missing values. soon vroom supports column-level missing values, able remedy !","code":"ex |>   mutate(     favorite_color = ifelse(age < 18, na(\"REDACTED\"), favorite_color)   ) #> # A tibble: 11 × 3 #>    person_id       age favorite_color #>    <dbl,fct> <dbl,fct> <chr>          #>  1         1        20 BLUE           #>  2         2 <REFUSED> <NA>           #>  3         3        21 <NA>           #>  4         4        30 <NA>           #>  5         5         1 <NA>           #>  6         6        41 RED            #>  7         7        50 <NA>           #>  8         8        30 YELLOW         #>  9         9 <REFUSED> <NA>           #> 10        10 <OMITTED> <NA>           #> 11        11        10 <NA> ex |>   mutate(     favorite_color = if_else(       age < 18,       na(\"REDACTED_UNDERAGE\"),       favorite_color,       missing = na(\"REDACTED_MISSING_AGE\")     )   ) #> # A tibble: 11 × 3 #>    person_id       age favorite_color         #>    <dbl,fct> <dbl,fct> <chr,fct>              #>  1         1        20 BLUE                   #>  2         2 <REFUSED> <REDACTED_MISSING_AGE> #>  3         3        21 <REFUSED>              #>  4         4        30 <OMITTED>              #>  5         5         1 <REDACTED_UNDERAGE>    #>  6         6        41 RED                    #>  7         7        50 <OMITTED>              #>  8         8        30 YELLOW                 #>  9         9 <REFUSED> <REDACTED_MISSING_AGE> #> 10        10 <OMITTED> <REDACTED_MISSING_AGE> #> 11        11        10 <REDACTED_UNDERAGE>"},{"path":"http://kylehusmann.com/interlacer/index.html","id":"related-work","dir":"","previous_headings":"","what":"Related work","title":"Read Tabular Data With Interlaced Values And Missing Reasons","text":"interlacer inspired haven, labelled, declared packages. packages provide similar functionality interlacer, focused providing compatibility missing reason data imported SPSS, SAS, Stata. interlacer slightly different aims: fully generic: Add missing value channel vector type. Provide functions reading / writing interlaced CSV files (just SPSS / SAS / Stata files) Provide functional API integrates well tidy pipelines Future versions interlacer provide functions convert packages’ types. detailed discussion, see vignette(\"-approaches\").","code":""},{"path":"http://kylehusmann.com/interlacer/index.html","id":"acknowledgements","dir":"","previous_headings":"","what":"Acknowledgements","title":"Read Tabular Data With Interlaced Values And Missing Reasons","text":"development software supported, whole part, Institute Education Sciences, U.S. Department Education, Grant R305A170047 Pennsylvania State University. opinions expressed authors represent views Institute U.S. Department Education.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/flatten_channels.html","id":null,"dir":"Reference","previous_headings":"","what":"Flatten a interlaced vector — flatten_channels","title":"Flatten a interlaced vector — flatten_channels","text":"flatten_channels() flattens interlaced vector single channel. useful step right writing interlaced vector file, example.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/flatten_channels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flatten a interlaced vector — flatten_channels","text":"","code":"flatten_channels(x, ...)"},{"path":"http://kylehusmann.com/interlacer/reference/flatten_channels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flatten a interlaced vector — flatten_channels","text":"x interlaced vector ... Additional arguments, used","code":""},{"path":"http://kylehusmann.com/interlacer/reference/flatten_channels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flatten a interlaced vector — flatten_channels","text":"vector, flattened","code":""},{"path":"http://kylehusmann.com/interlacer/reference/interlaced.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct an interlaced vector — interlaced","title":"Construct an interlaced vector — interlaced","text":"interlaced type extends vectors adding \"missing reason\" channel can used distinguish different types missingness. interlaced() function constructs new interlaced vector vector list values.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/interlaced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct an interlaced vector — interlaced","text":"","code":"interlaced(x, na = NULL)  as.interlaced(x, na = NULL, ...)  # S3 method for default as.interlaced(x, na = NULL, ...)  # S3 method for interlacer_interlaced as.interlaced(x, ...)  # S3 method for data.frame as.interlaced(x, ...)  is.interlaced(x)"},{"path":"http://kylehusmann.com/interlacer/reference/interlaced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct an interlaced vector — interlaced","text":"x vector list values na vector values interpret missing values ... Additional arguments, used","code":""},{"path":"http://kylehusmann.com/interlacer/reference/interlaced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct an interlaced vector — interlaced","text":"interlaced vector","code":""},{"path":"http://kylehusmann.com/interlacer/reference/interlacer_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a path to one of interlacer's example data sets — interlacer_example","title":"Get a path to one of interlacer's example data sets — interlacer_example","text":"interlacer comes bundled number sample files inst/extdata directory. function make easy access","code":""},{"path":"http://kylehusmann.com/interlacer/reference/interlacer_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a path to one of interlacer's example data sets — interlacer_example","text":"","code":"interlacer_example(file = NULL)"},{"path":"http://kylehusmann.com/interlacer/reference/interlacer_example.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a path to one of interlacer's example data sets — interlacer_example","text":"file Name file. NULL, example files listed.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/interlacer_example.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a path to one of interlacer's example data sets — interlacer_example","text":"","code":"interlacer_example() #> [1] \"colors.csv\"            \"colors.dta\"            \"colors.sav\"            #> [4] \"colors_coded.csv\"      \"colors_coded_char.csv\" \"stress.csv\"            interlacer_example(\"colors.csv\") #> [1] \"/home/runner/work/_temp/Library/interlacer/extdata/colors.csv\""},{"path":"http://kylehusmann.com/interlacer/reference/is.empty.html","id":null,"dir":"Reference","previous_headings":"","what":"NA missing reasons — is.empty","title":"NA missing reasons — is.empty","text":"value missing value missing reason, considered \"empty\". .empty() checks type values. Regular NA values (missing reasons) also considered \"empty\".","code":""},{"path":"http://kylehusmann.com/interlacer/reference/is.empty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NA missing reasons — is.empty","text":"","code":"is.empty(x)"},{"path":"http://kylehusmann.com/interlacer/reference/is.empty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NA missing reasons — is.empty","text":"x vector","code":""},{"path":"http://kylehusmann.com/interlacer/reference/is.empty.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"NA missing reasons — is.empty","text":"logical vector length x, containing TRUE empty elements, FALSE otherwise.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/map_value_channel.html","id":null,"dir":"Reference","previous_headings":"","what":"interlaced functional utilities — map_value_channel","title":"interlaced functional utilities — map_value_channel","text":"map_value_channel() modifies values interlaced vector. map_na_channel() modifies missing reason channel interlaced vector.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/map_value_channel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"interlaced functional utilities — map_value_channel","text":"","code":"map_value_channel(x, fn)  map_na_channel(x, fn)"},{"path":"http://kylehusmann.com/interlacer/reference/map_value_channel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"interlaced functional utilities — map_value_channel","text":"x interlaced vector fn function maps values missing reasons new values","code":""},{"path":"http://kylehusmann.com/interlacer/reference/map_value_channel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"interlaced functional utilities — map_value_channel","text":"new interlaced vector, modified according supplied function","code":""},{"path":"http://kylehusmann.com/interlacer/reference/na.html","id":null,"dir":"Reference","previous_headings":"","what":"Lift values to missing reasons — na","title":"Lift values to missing reasons — na","text":"na() lifts value interlaced missing reason channel.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lift values to missing reasons — na","text":"","code":"na(x = unspecified())"},{"path":"http://kylehusmann.com/interlacer/reference/na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lift values to missing reasons — na","text":"x character numeric value","code":""},{"path":"http://kylehusmann.com/interlacer/reference/na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lift values to missing reasons — na","text":"interlaced value","code":""},{"path":"http://kylehusmann.com/interlacer/reference/na_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an NA column specification — na_cols","title":"Create an NA column specification — na_cols","text":"na_cols() creates specification NA channel missing reason loading data read_interlaced_*() family functions.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/na_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an NA column specification — na_cols","text":"","code":"na_cols(...)  as.na_col_spec(x)  is.na_col_spec(x)"},{"path":"http://kylehusmann.com/interlacer/reference/na_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an NA column specification — na_cols","text":"... Named vectors use missing reasons loading interlaced columns. Use name .default set default NA values columns. x Named list construct NA spec , vector values used spec .default equal values.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/na_levels.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the factor levels of the value or missing reason channel — na_levels","title":"Get the factor levels of the value or missing reason channel — na_levels","text":"base S3 levels() function overloaded interlaced vectors, value channel factor type, levels() return levels. Similarly na_levels() return levels missing reason channel, factor type.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/na_levels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the factor levels of the value or missing reason channel — na_levels","text":"","code":"na_levels(x)  na_levels(x) <- value  # S3 method for interlacer_interlaced levels(x)  # S3 method for interlacer_interlaced levels(x) <- value"},{"path":"http://kylehusmann.com/interlacer/reference/na_levels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the factor levels of the value or missing reason channel — na_levels","text":"x interlaced vector value new levels set","code":""},{"path":"http://kylehusmann.com/interlacer/reference/na_levels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the factor levels of the value or missing reason channel — na_levels","text":"levels values missing reason channel","code":""},{"path":"http://kylehusmann.com/interlacer/reference/na_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Examine the NA spec of a data frame — na_spec","title":"Examine the NA spec of a data frame — na_spec","text":"Like readr::spec(), na_spec() extracts NA column specification tibble created read_interlaced_*","code":""},{"path":"http://kylehusmann.com/interlacer/reference/na_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Examine the NA spec of a data frame — na_spec","text":"","code":"na_spec(x)"},{"path":"http://kylehusmann.com/interlacer/reference/na_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Examine the NA spec of a data frame — na_spec","text":"x data frame object extract ","code":""},{"path":"http://kylehusmann.com/interlacer/reference/na_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Examine the NA spec of a data frame — na_spec","text":"na_col_spec object","code":""},{"path":"http://kylehusmann.com/interlacer/reference/parse_interlaced.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse a character vector into an interlaced vector type — parse_interlaced","title":"Parse a character vector into an interlaced vector type — parse_interlaced","text":"parse_interlaced converts character vector interlaced vector parsing readr collector type.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/parse_interlaced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse a character vector into an interlaced vector type — parse_interlaced","text":"","code":"parse_interlaced(x, na, .value_col = col_guess())"},{"path":"http://kylehusmann.com/interlacer/reference/parse_interlaced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse a character vector into an interlaced vector type — parse_interlaced","text":"x character vector na vector values interpret missing values .value_col collector parse character values (e.g. readr::col_double(), readr::col_integer(), etc.)","code":""},{"path":"http://kylehusmann.com/interlacer/reference/parse_interlaced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse a character vector into an interlaced vector type — parse_interlaced","text":"interlaced vector","code":""},{"path":"http://kylehusmann.com/interlacer/reference/read_interlaced_delim.html","id":null,"dir":"Reference","previous_headings":"","what":"Read an delimited file with interlaced missing reasons into a tibble — read_interlaced_delim","title":"Read an delimited file with interlaced missing reasons into a tibble — read_interlaced_delim","text":"read_interlaced_*(), family functions extend readr's read_delim(), read_csv, etc. functions use data sources values interlaced missing reasons. functions return tibble interlaced columns.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/read_interlaced_delim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read an delimited file with interlaced missing reasons into a tibble — read_interlaced_delim","text":"","code":"read_interlaced_delim(   file,   delim = NULL,   quote = \"\\\"\",   escape_backslash = FALSE,   escape_double = TRUE,   col_names = TRUE,   col_types = NULL,   col_select = NULL,   id = NULL,   locale = readr::default_locale(),   na = c(\"\", \"NA\"),   comment = \"\",   trim_ws = FALSE,   skip = 0,   n_max = Inf,   guess_max = min(1000, n_max),   name_repair = \"unique\",   progress = readr::show_progress(),   show_col_types = readr::should_show_types(),   skip_empty_rows = TRUE )  read_interlaced_csv(   file,   col_names = TRUE,   col_types = NULL,   col_select = NULL,   id = NULL,   locale = readr::default_locale(),   na = c(\"\", \"NA\"),   quote = \"\\\"\",   comment = \"\",   trim_ws = TRUE,   skip = 0,   n_max = Inf,   guess_max = min(1000, n_max),   name_repair = \"unique\",   progress = readr::show_progress(),   show_col_types = readr::should_show_types(),   skip_empty_rows = TRUE )  read_interlaced_csv2(   file,   col_names = TRUE,   col_types = NULL,   col_select = NULL,   id = NULL,   locale = readr::default_locale(),   na = c(\"\", \"NA\"),   quote = \"\\\"\",   comment = \"\",   trim_ws = TRUE,   skip = 0,   n_max = Inf,   guess_max = min(1000, n_max),   name_repair = \"unique\",   progress = readr::show_progress(),   show_col_types = readr::should_show_types(),   skip_empty_rows = TRUE )  read_interlaced_tsv(   file,   col_names = TRUE,   col_types = NULL,   col_select = NULL,   id = NULL,   locale = readr::default_locale(),   na = c(\"\", \"NA\"),   quote = \"\\\"\",   comment = \"\",   trim_ws = TRUE,   skip = 0,   n_max = Inf,   guess_max = min(1000, n_max),   name_repair = \"unique\",   progress = readr::show_progress(),   show_col_types = readr::should_show_types(),   skip_empty_rows = TRUE )  interlaced_vroom(   file,   delim = NULL,   col_names = TRUE,   col_types = NULL,   col_select = NULL,   id = NULL,   skip = 0,   n_max = Inf,   na = c(\"\", \"NA\"),   quote = \"\\\"\",   comment = \"\",   skip_empty_rows = TRUE,   trim_ws = TRUE,   escape_double = TRUE,   escape_backslash = FALSE,   locale = vroom::default_locale(),   guess_max = 100,   progress = vroom::vroom_progress(),   show_col_types = NULL,   .name_repair = \"unique\" )"},{"path":"http://kylehusmann.com/interlacer/reference/read_interlaced_delim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read an delimited file with interlaced missing reasons into a tibble — read_interlaced_delim","text":"file Either path file, connection, literal data (either single string raw vector). Files ending .gz, .bz2, .xz, .zip automatically uncompressed. Files starting http://, https://, ftp://, ftps:// automatically downloaded. Remote gz files can also automatically downloaded decompressed. Literal data useful examples tests. recognised literal data, input must either wrapped (), string containing least one new line, vector containing least one string new line. Using value clipboard() read system clipboard. delim Single character used separate fields within record. quote Single character used quote strings. escape_backslash file use backslashes escape special characters? general escape_double backslashes can used escape delimiter character, quote character, add special characters like \\\\n. escape_double file escape quotes doubling ? .e. option TRUE, value \"\"\"\" represents single quote, \\\". col_names Either TRUE, FALSE character vector column names. TRUE, first row input used column names, included data frame. FALSE, column names generated automatically: X1, X2, X3 etc. col_names character vector, values used names columns, first row input read first row output data frame. Missing (NA) column names generate warning, filled dummy names ...1, ...2 etc. Duplicate column names generate warning made unique, see name_repair control done. col_types One NULL, cols() specification, string. See vignette(\"readr\") details. NULL, column types inferred guess_max rows input, interspersed throughout file. convenient (fast), robust. guessed types wrong, need increase guess_max supply correct types . Column specifications created list() cols() must contain one column specification column. want read subset columns, use cols_only(). Alternatively, can use compact string representation character represents one column: c = character = integer n = number d = double l = logical f = factor D = date T = date time t = time ? = guess _ - = skip default, reading file without column specification print message showing readr guessed . remove message, set show_col_types = FALSE set options(readr.show_col_types = FALSE). col_select Columns include results. can use mini-language dplyr::select() refer columns name. Use c() use one selection expression. Although usage less common, col_select also accepts numeric column index. See ?tidyselect::language full details selection language. id name column store file path. useful reading multiple input files data file paths, data collection date. NULL (default) extra column created. locale locale controls defaults vary place place. default locale US-centric (like R), can use locale() create locale controls things like default time zone, encoding, decimal mark, big mark, day/month names. na NA col spec defined na_cols() character numeric vector values interpret missing values. comment string used identify comments. text comment characters silently ignored. trim_ws leading trailing whitespace (ASCII spaces tabs) trimmed field parsing ? skip Number lines skip reading data. comment supplied commented lines ignored skipping. n_max Maximum number lines read. guess_max Maximum number lines use guessing column types. never use number lines read. See vignette(\"column-types\", package = \"readr\") details. name_repair, .name_repair Handling column names. default behaviour ensure column names \"unique\". Various repair strategies supported: \"minimal\": name repair checks, beyond basic existence names. \"unique\" (default value): Make sure names unique empty. \"check_unique\": name repair, check unique. \"unique_quiet\": Repair unique strategy, quietly. \"universal\": Make names unique syntactic. \"universal_quiet\": Repair universal strategy, quietly. function: Apply custom name repair (e.g., name_repair = make.names names style base R). purrr-style anonymous function, see rlang::as_function(). argument passed repair vctrs::vec_as_names(). See details terms strategies used enforce . progress Display progress bar? default display interactive session knitting document. automatic progress bar can disabled setting option readr.show_progress FALSE. show_col_types FALSE, show guessed column types. TRUE always show column types, even supplied. NULL (default) show column types explicitly supplied col_types argument. skip_empty_rows blank rows ignored altogether? .e. option TRUE blank rows represented .  FALSE represented NA values columns.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/read_interlaced_delim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read an delimited file with interlaced missing reasons into a tibble — read_interlaced_delim","text":"tibble(), interlaced columns.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/read_interlaced_delim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read an delimited file with interlaced missing reasons into a tibble — read_interlaced_delim","text":"","code":"# Beep boop"},{"path":"http://kylehusmann.com/interlacer/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. generics .factor, .ordered readr .col_spec, col_character, col_date, col_datetime, col_double, col_factor, col_guess, col_integer, col_logical, col_number, col_skip, col_time, cols, cols_condense, cols_only, spec vctrs vec_c","code":""},{"path":"http://kylehusmann.com/interlacer/reference/value_channel.html","id":null,"dir":"Reference","previous_headings":"","what":"Access the channels of an interlaced vector — value_channel","title":"Access the channels of an interlaced vector — value_channel","text":"value_channel() returns value channel interlaced vector na_channel() returns missing reason channel interlaced vector","code":""},{"path":"http://kylehusmann.com/interlacer/reference/value_channel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access the channels of an interlaced vector — value_channel","text":"","code":"value_channel(x, ...)  na_channel(x, ...)"},{"path":"http://kylehusmann.com/interlacer/reference/value_channel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access the channels of an interlaced vector — value_channel","text":"x interlaced vector ... Additional arguments, used","code":""},{"path":"http://kylehusmann.com/interlacer/reference/value_channel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access the channels of an interlaced vector — value_channel","text":"value missing reasons channel","code":""},{"path":"http://kylehusmann.com/interlacer/reference/write_interlaced_delim.html","id":null,"dir":"Reference","previous_headings":"","what":"Interlace a deinterlaced data frame and write it to a file — write_interlaced_delim","title":"Interlace a deinterlaced data frame and write it to a file — write_interlaced_delim","text":"write_interlaced_*() family functions take data frame interlaced columns, flatten interlaced columns, write file. Non-interlaced columns just pass . behavior functions match similarly named counterparts readr.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/write_interlaced_delim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interlace a deinterlaced data frame and write it to a file — write_interlaced_delim","text":"","code":"write_interlaced_delim(   x,   file,   delim = \" \",   empty = \"NA\",   append = FALSE,   col_names = !append,   quote = c(\"needed\", \"all\", \"none\"),   escape = c(\"double\", \"backslash\", \"none\"),   eol = \"\\n\",   num_threads = readr::readr_threads(),   progress = readr::show_progress() )  write_interlaced_csv(   x,   file,   empty = \"NA\",   append = FALSE,   col_names = !append,   quote = c(\"needed\", \"all\", \"none\"),   escape = c(\"double\", \"backslash\", \"none\"),   eol = \"\\n\",   num_threads = readr::readr_threads(),   progress = readr::show_progress() )  write_interlaced_csv2(   x,   file,   empty = \"NA\",   append = FALSE,   col_names = !append,   quote = c(\"needed\", \"all\", \"none\"),   escape = c(\"double\", \"backslash\", \"none\"),   eol = \"\\n\",   num_threads = readr::readr_threads(),   progress = readr::show_progress() )  write_interlaced_excel_csv(   x,   file,   empty = \"NA\",   append = FALSE,   col_names = !append,   quote = c(\"needed\", \"all\", \"none\"),   escape = c(\"double\", \"backslash\", \"none\"),   eol = \"\\n\",   num_threads = readr::readr_threads(),   progress = readr::show_progress() )  write_interlaced_excel_csv2(   x,   file,   empty = \"NA\",   append = FALSE,   col_names = !append,   quote = c(\"needed\", \"all\", \"none\"),   escape = c(\"double\", \"backslash\", \"none\"),   eol = \"\\n\",   num_threads = readr::readr_threads(),   progress = readr::show_progress() )  write_interlaced_tsv(   x,   file,   empty = \"NA\",   append = FALSE,   col_names = !append,   quote = c(\"needed\", \"all\", \"none\"),   escape = c(\"double\", \"backslash\", \"none\"),   eol = \"\\n\",   num_threads = readr::readr_threads(),   progress = readr::show_progress() )"},{"path":"http://kylehusmann.com/interlacer/reference/write_interlaced_delim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interlace a deinterlaced data frame and write it to a file — write_interlaced_delim","text":"x data frame tibble write disk. file File connection write . delim Delimiter used separate values. Defaults \" \" write_delim(), \",\" write_excel_csv() \";\" write_excel_csv2(). Must single character. empty String used empty values (NA values non-interlaced columns). Defaults NA. append FALSE, overwrite existing file. TRUE, append existing file. cases, file exist new file created. col_names FALSE, column names included top file. TRUE, column names included. specified, col_names take opposite value given append. quote handle fields contain characters need quoted. needed - Values quoted needed: contain delimiter, quote, newline. - Quote fields. none - Never quote fields. escape type escape use quotes data. double - quotes escaped doubling . backslash - quotes escaped preceding backslash. none - quotes escaped. eol end line character use. commonly either \"\\n\" Unix style newlines, \"\\r\\n\" Windows style newlines. num_threads Number threads use reading materializing vectors. data contains newlines within fields parser automatically forced use single thread . progress Display progress bar? default display interactive session knitting document. display updated every 50,000 values display estimated reading time 5 seconds . automatic progress bar can disabled setting option readr.show_progress FALSE.","code":""},{"path":"http://kylehusmann.com/interlacer/reference/write_interlaced_delim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interlace a deinterlaced data frame and write it to a file — write_interlaced_delim","text":"write_interlaced_* returns input x invisibly","code":""}]
