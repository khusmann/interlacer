% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interlaced-tidy-helpers.R
\name{across_value_channels}
\alias{across_value_channels}
\alias{across_na_channels}
\title{Apply a function across the value or missing reason channels of multiple
columns}
\usage{
across_value_channels(.cols, .fns, .names = NULL, .unpack = FALSE)

across_na_channels(.cols, .fns, .names = NULL, .unpack = FALSE)
}
\arguments{
\item{.cols}{<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> Columns to transform.
You can't select grouping columns because they are already automatically
handled by the verb (i.e. \code{\link[dplyr:summarise]{summarise()}} or \code{\link[dplyr:mutate]{mutate()}}).}

\item{.fns}{Functions to apply to each of the selected columns.
Possible values are:
\itemize{
\item A function, e.g. \code{mean}.
\item A purrr-style lambda, e.g. \code{~ mean(.x, na.rm = TRUE)}
\item A named list of functions or lambdas, e.g.
\verb{list(mean = mean, n_miss = ~ sum(is.na(.x))}. Each function is applied
to each column, and the output is named by combining the function name
and the column name using the glue specification in \code{.names}.
}

Within these functions you can use \code{\link[dplyr:cur_column]{cur_column()}} and \code{\link[dplyr:cur_group]{cur_group()}}
to access the current column and grouping keys respectively.}

\item{.names}{A glue specification that describes how to name the output
columns. This can use \code{{.col}} to stand for the selected column name, and
\code{{.fn}} to stand for the name of the function being applied. The default
(\code{NULL}) is equivalent to \code{"{.col}"} for the single function case and
\code{"{.col}_{.fn}"} for the case where a list is used for \code{.fns}.}

\item{.unpack}{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

Optionally \link[tidyr:pack]{unpack} data frames returned by functions in
\code{.fns}, which expands the df-columns out into individual columns, retaining
the number of rows in the data frame.
\itemize{
\item If \code{FALSE}, the default, no unpacking is done.
\item If \code{TRUE}, unpacking is done with a default glue specification of
\code{"{outer}_{inner}"}.
\item Otherwise, a single glue specification can be supplied to describe how to
name the unpacked columns. This can use \code{{outer}} to refer to the name
originally generated by \code{.names}, and \code{{inner}} to refer to the names of
the data frame you are unpacking.
}}
}
\value{
like \code{dplyr::across()}, \code{across_value_channels()} and
\code{across_na_channels()} return a tibble with one column for each column in
\code{.cols} and each function in \code{.fns}
}
\description{
\code{across_value_channels()} and \code{across_na_channels()} are simple wrappers
\code{dplyr::across()} that applies transformations to value or missing reason
channels, respectively.
}
\seealso{
Other interlaced tidy helpers: 
\code{\link{where_value_channel}()}
}
\concept{interlaced tidy helpers}
